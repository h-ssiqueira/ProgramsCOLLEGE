Inicialmente, gerar uma chave aleatória não era uma boa opção, pois poderia haver duplicidade em uma mesma execução mesmo com o uso de threads. Por isso é importante realizar de forma sequencial o ataque de força bruta para que não haja repetições e que o programa possa testar todas as possíveis possibilidades até que encontre a chave gerada. Além disso, se for utilizado a função "printf", o tempo ficaria ainda maior por conta da exibição na tela, ou seja, há mais consumo para se exibir na tela do que para realizar as operações de testes. Também, sem a utilização da biblioteca "<time.h>" e a função "srand(time(NULL))" a chave seria a mesma para um mesmo tamanho, dependendo apenas da ordem das letras da cadeia de caracteres da função que gera a chave.

Para realizar a função sequencial, é necessário que a cadeia de caracteres comece com todos os caracteres 'a' e que termine a função com todos os caracteres com 'z', caso a chave secreta fosse todos os caracteres com 'z'. Ao chegar no caracter '{' em uma posição da cadeia ('z'(122)+1 = '{'(123)) há a necessidade de retornar ao caracter 'a' e avançar uma posição no caracter da esquerda, com exceção do primeiro caracter da cadeia (pois não haverá outro caracter à esquerda), assim como uma operação matemática, porém com letras no lugar de números.

Utilizando threads, no caso de duas, há a divisão do intervalo pela metade, ou seja, uma cadeia de caracteres com a inicial preenchida (de 'a' até 'm') e outra com inicial preenchida (de 'n' até 'z'). Sendo que a chave não fará parte de um dos intervalos, ocasionando a continuação da mesma thread, porém, após a leitura da documentação da biblioteca "<pthreads.h>", a função "pthread_join" faz com que a aplicação principal espere até que a thread seja terminada, no caso de mais de uma thread, a thread que encontrar a chave secreta terminará a execução primeiro, porém a(s) outra(s) thread(s) ainda continuará(ão) em execução. Para resolver isso, há duas possibilidades, uma de encerrar a execução do programa logo em que há a descoberta da chave secreta a partir de um "exit(0)" ou a possibilidade de adicionar uma variável booleana global que identifica se a chave foi encontrada e esta variável colocada junto ao loop da função que executará via threads, interrompendo, assim, a execução das demais threads caso uma encontre a chave secreta.

No caso de 8 caracteres de letras minúsculas, se executado sem a utilização de threads no pior caso o programa teria 26^8 combinações para serem testadas, com a utilização de duas threads o tempo de execução seria a metade ((26^8)/2) e com a utilização de 4 threads o tempo de execução seria um quarto do original ((26^8)/4).

(atualização)

Porém, se utilizar o recurso de variável global booleana há a consequência de região crítica do código fazendo com que as demais threads possam continuar executando, assim o uso do "exit(0)" é o mais correto a ser utilizado. Após testes foi notado que ao utilizar -O3 ou -Ofast na compilação do programa utilizando região crítica, o programa ao executar continuou sua execução das threads mesmo após ter encontrado a chave secreta.

Além disso, houve a necessidade de colocar um sleep entre cada execução de thread para que houvesse a correta passagem do parâmetro da cadeia de caracteres, pois caso não houvesse a mesma, haveria valores distintos do previsto assim como poderia haver um número menor de threads do que o esperado. Entretanto, mesmo com a função sleep, há a correta passagem de valores de caracteres para a função de força bruta, mas o "printf" que indicaria a quantidade de instruções feitas (em centenas de milhões) indica o valor incorreto desta mesma cadeia de caracteres.